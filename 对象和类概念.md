1. 对象和类概念

- 对象：任何一个对象都应该具备两个要素：属性、行为。

在C++中每个对象都有数据（体现了属性）和函数（用来对数据进行操作，以实现某些功能）两部分组成。

- 类：具有共性的实体的抽象。

类是对象的抽象，不占有内存。对象是类的特例，即类的具体表现形式，占有存储空间。

C++使用class关键字用于定义类，和struct关键字的用法相同。只不过class关键字默认的类型为private.私有成员只能被本类中的成员函数调用。

2. 面向对象的三大特性：封装、继承、多态。

- 封装：将方法和数据封装在类里面，可以根据访问限定符的使用保证数据的安全性，隐藏了方法的实现细节，也方便使用。封装的目的是增强安全性和简化编程，使用者不必了解具体的实现细节，而只是通过外部接口以及特定的访问权限来使用类的成员。

- 继承：对已有类增加属性和功能或进行部分修改来建立新的类，是实现代码的复用的重要手段，继承是类型之间的关系建模。继承可以使得子类具有父类的各种属性和方法，而不需要再次编写相同的代码，在令子类继承父类的同时，可以重新定义某些属性，并重新某些方法，即覆盖父类的原有属性和方法，使其获得与父类不同的功能，继承是指一个对象直接使用另一个对象的属性和方法。

- 多态：在面向对象的程序里面，同一个消息被不同的对象接受后可以导致不同的行为，是接口的多种不同的实现方式，极大的提高了代码的重用。多态性，允许将子类类型的指针赋值给父类类型的指针，多态性在C++中是通过虚函数实现的。虚函数就是允许被其子类重新定义的成员函数。而子类重新定义父类虚函数的做法，称为“覆盖”，或者称为“重写”。子类重写父类中虚函数时，即使不用virtual声明，该重载函数也是虚函数。

- 抽象：表示同一类事务的本质。

3. 对象的引用

- 同一类的对象可以相互赋值。

- 在一个类中至少有一个公用的成员函数作为对外的接口。公用成员函数是用户使用类的公用接口，或者类的对外接口。外界只能通过公用成员函数来实现对类内的私有函数进行操作。

- 当类中有指针且有动态内存分配时，不要随便赋值，有可能会出现问题。

- ::是作用域的限定符，声明函数或者变量是属于哪个类的。

- 内置成员函数：C++对一般的内置函数需要使用关键字inline声明，在调用函数时，并不是真正的执行调用的过程，而是把函数的代码嵌入程序的调用点，大大减少调用函数的时间开销。对于类内定义的成员函数，可以省略关键字inline，C++默认类内的成员函数为内置函数。但是如果陈元函数在类体外定义时，系统并不默认为内置函数，需要在声明与定义的时候加上inline关键字说明（必须将类定义和成员函数的定义放在同一个头文件中或者卸载同一个源文件中，否则编译无法进行置换）。

- C++对类的每个对象所占有的存储空间只是该对象的数据成员所占有额存储空间，而不包括函数代码所占有的存储空间，与成员函数无关。而这些对象的成员函数对应的是同一个函数代码段。

- 不管成员函数在类内定义还是类外定义，不论是否用inline声明，成员函数的代码段的存储方式是相同的，都不占用对象的存储空间。Inline函数只影响程序的执行效率，而与成员函数是否占有对象的存储空间无关。

- 对象成员引用的方式：

1. 通过对象名与成员运算符访问对象中的成员    对象名.成员名

2. 通过指向对象的指针访问对象的成员                 指针—>成员名

3. 通过对象的引用来访问对象的成员。

类的公用接口与实现分离：

通过成员函数对数据进行操作称为类的功能实现，为了防止用户任意的修改公用成员函数，改变对数据进行的操作，往往不让用户看到公用成员函数的源代码，用户只能接触到公用函数的目标代码。类内被操作的数据是私有的，类的功能实现细节是对用户屏蔽的。这种实现称为私有实现。这种类的公用借口与实现分离形成了信息屏蔽，用户接触到的是公用接口，而不能接触到被屏蔽的数据与实现的细节。

（1）如果要修改或扩充类的功能，只需修改该类中有关的数据成员与成员函数，成语中类以外的部分可以不必修改。

（2）编译时发现勒种的数据读写有错，不必检查整个程序，只需要检查本类中访问的这些数据的少数成员函数。

把类的声明放在指定的头文件中，用户要使用该类，只需要把有关的头文件包含进来即可。不必再程序中重复书写类的声明，以减少工作量，节省篇幅，提高编程的效率。

一个C++程序是有3部分组成：

（1）类声明的头文件（.h）。

（2）类实现文件（.cpp）包含类成员函数的定义。

（3）类的使用文件（.cpp）即主函数文件。

4. 构造函数

    构造函数主要用于在定义对象时，完成对象的初始化.
    
    每一个类都应该有一个构造函数，如果用户没有定义构造函数，编译器会自动生成构造函数(参数和函数体为空的构造函数)，如果用户自定义了构造函数，那么编译器不再提供默认的构造函数。
    
    特性：1.构造函数的名称必须要与当前类的名称相同。
    
          2.构造函数仅在定义对象时由系统调用，其他时间无法调用。而且只执行一次。
    
          3.构造函数可以有参数，也可以没有参数，但是不允许有返回值。
    
          4.构造函数只能定义为公有成员，不能定义为其他。

（1）构造函数可以进行重载，以便用于不同形式的对象的定义。

（2）构造函数还可以使用默认的缺省参数。如果构造函数既有重载，又有缺省参数时，注意不要产生二义性。

参数初始化表：

除了构造函数进行对成员数据进行初始化，还有参数初始化表对数据初始化，在函数首部实现。

如果数据成员是数组，则需要在构造函数的函数体内用语句对其复制，不能再参数初始化表中进行对其初始化。

构造函数的重载：

在一个类中定义多个构造函数名具有相同的名字，而参数的个数或者参数的类型不同。

5. 析构函数

    析构函数是一种特殊的成员函数，完成与构造函数相反的工作，对象退出生命周期时，完成清理的工作。如：释放内存等。
    
    特性：
    
    1.析构函数的名称与类的名称相同。为了区分，析构函数名字前面有~
    
        构造：stu(){}       析构：~stu(){}
    
    2.析构函数无参、无返回值。
    
    3.析构函数不可重载。每一个类有且只有一个析构函数，但是可以有多个构造函数。
    
    4.在对象退出生命周期时，编译器会自动调用析构函数。但是，可以人为调用析构函数，不过没意义。
    
    5.一般情况下，使用系统默认的析构函数就可以。当类中有动态内存分配时，需要增加自定义的析构函数，否则有可能会导致内存泄露。
    
    调用条件：
    
        1.对象退出生命周期时。定义的对象在调用结束后释放时自动执行析构函数。
    
        2.释放动态分配的对象空间。使用new运算符动态的建立了一个对象，当使用delete运算符释放该对象时，先调用该对象的析构函数。

- 定义的全局的对象在程序离开其作用域的时候调用该全局对象的析构函数。

- 静态（static）局部对象在程序调用结束时对象并不释放，因此也不调用析构函数，只在main函数结束或调用exit函数结束程序时，才调用static局部对象的析构函数。

6.  析构顺序

同一作用域下，先构造的后析构。即最先被调用构造函数，其对应的析构函数最后被调用，先进后出。

调用析构函数的顺序与存储类别有关。

7. this指针

指向本类对象的指针，它的值是当前被调用的成员函数所在的对象的起始地址。this指针是隐式使用的，它是作为参数被传递给成员函数的。

8. 常对象：

类名 const 对象名[（实参表）]     或者     Const 类名 对象名[（实参表）]

在定义的时候必须初始化，如果一个对象声明为常对象，只能调用该对象的常成员函数，而不能调用其他的一般成员函数。常成员函数是常对象的唯一对外接口。常成员函数可以访问常对象中的数据成员，但是不允许修改对象中数据的值。但是一般的成员函数可以引用类中的非const数据成员也可以改变他们。

9. 常对象成员

常对象的数据成员都是常数据成员，必须通过构造函数的参数初始化表对常数据成员进行初始化。

Const int hour;

Time::Time(int h):hour(h){}

常成员函数：可以访问常对象中的数据成员，但是不允许修改对象中数据的值。

类型名 函数名（参数表） const；

10. 指向常对象的指针变量

Const 类型名 * 指针变量名

如果一个变量声明为常变量，只能用指向常变量的指针向量指向它。

指向常变量的指针变量除了可以指向常变量外，也可以指向未被声明为const的变量，但是不可通过该指针变量改变变量的值。

当希望在调用函数时，对象的值不被修改，就应当把形参定义为指向常变量的指针变量，同时用对象的地址作为实参（对象可以是const或者非const型的）如果要求该对象不仅在调用函数的时候不被改变，而且要求它在程序执行的过程都不被调用，则需要把对象也定义为const型。

Time const t;             t是一个常对象，其值在任何情况下都不能改变。

Void Time::fun() const;    fun是Time类中的常成员函数，可以引用，但是不能改变本类中的数据成员。

Time *const p;           p是指向Time类对象的常指针变量，p的值不能改变。

Const Time *p;           p是指向Time类对象的指针变量，P指向的类对象的值不可以通过p来改变。

Const Time &t1=t;        t1是Time 类对象t的引用，二者指向同一个存储空间，t的值不能改变。

11.  对象的动态建立与释放

在C语言中是利用库函数malloc和free来分配和撤销内存空间的。C++提供了简便而功能较强的运算符new和delete来取代malloc和free函数。

- new和delete是运算符，不是函数，因此执行效率高。

- 用new分配数组空间时不能指定初值。如果由于内存不足等原因而无法正常分配空间，则new会返回一个空指针NULL（0值），用户可以根据该指针的值判断分配空间是否成功。

- Box *pt;  //定义一个指向Box类对象的指针变量pt
  pt=new Box;  //在pt中存放了新建对象的起始地址

- delete 指针名; 如果被删除的是普通变量，则会直接释放动态分配的内存。如果被删除的是对象，则该对象的析构函数被调用。这里要注意一下，用new动态分配的内存只能用delete释放一次，如果释放第二次会出现错误。

12. 对象的赋值：对象名2=对象名1；//是对一个已经存在的对象赋值，必须向定义被赋值的对象，才能进行赋值。

对象的复制：类名 对象名2（对象名1）； 或者 类名 对象名2=对象名1； //用对象1复制出对象2，是从无到有的建立一个新的对象，并使它与一个已有的对象完全相同（包括对象的结构与成员的值）

拷贝构造函数（复制构造函数）：也是构造函数，但是只有一个参数，这个参数是本类的对象，而且采用对象的引用的形式（一般约定加const声明，使参数值不能改变）。此复制构造函数就是将实参对象的各成员值一一赋给新的对象中的成员。

复制构造函数与普通构造函数的区别

1. 形式上的不同：两者虽然函数名与类名相同，也不指定函数类型。但复制构造函数只有一个参数，并且是对同类对象的引用-------复制构造函数无法重载

 普通的构造函数：    类名（形参列表）

 拷贝构造函数：      类名（类名 &对象名）

2. 在建立对象的时候实参类型不同，系统会根据实参类型决定调用普通的构造函数还是拷贝构造函数。

在C++中，下面三种对象需要调用拷贝构造函数（有时也称“复制构造函数”）：

    1、使用已知对象初始化新对象。
    
        stu s2 = s1;
    
    2、如果函数参数是某类的对象
    
        void fun(stu s1){}
    
        fun(s2);
    
    3、如果函数返回值为某类的对象时。
    
        stu fun(){}
    
        stu s1 = fun();
    
        如果使用无名对象初始化新的对象，不会调用拷贝构造函数。

当类中有指针且进行动态内存分配时，要使用自定义的拷贝构造函数。

可以自定拷贝构造函数，如果自定义后，默认的拷贝构造函数失效。

        浅拷贝：只复制数据，没复制内存空间。
        
        深拷贝：既拷贝数据，也要复制内存空间。

13.  静态数据成员：

1) 如果希望各对象的数据成员的值是一样的，就将其定义为静态数据成员。为各个对象所共有，在内存中只占有一份空间，每个对象都可以引用。如果改变它的值，则在各个对象中数据成员的值都同时改变了。这样可以节省空间，提高效率。

2) 静态数据成员是还在所有对象之外单独开辟的空间，只要在类中定义了静态数据成员，即使不定义对象，也为静态的数据成员分配看空间，可以被引用。而且也不随着对象的撤销而释放，到程序结束后才释放空间。

3) 可以初始化，但是只能在类体外进行初始化。  数据类型 类名::静态数据成员名=初值；

4) 不能使用参数初始化表对静态成员数据进行初始化。编译系统会自动赋值为0；

5) 可以通过对象名引用，也可以通过类名引用。（它是属于类的，不是属于某个对象的）

6) 如果静态数据成员被定义为私有的，则不能在类外直接引用，必须经过公用的成员函数引用。

7) 有了静态数据成员，各对象之间有了沟通的渠道，实现数据共享，可以不使用全局变量，全局变量破坏了封装的原则，不符合面向对象的程序要求。

14.  静态成员函数：

1) 静态成员函数的意义，不在于信息共享，数据沟通，而在于管理静态数据成员，完成对静态数据成员的封装。

2) 静态成员函数只能访问静态数据成员。

3) 静态成员函数与非静态成员函数的根本区别：非静态成员函数在调用时 this指针时被当作参数传进。而静态成员函数属于类，而不属于对象，没有this 指针，所以不能访问本来中的非静态成员，但是可以引用本类中的静态数据成员，如果一定要引用本类中的非静态成员，需要加上对象名和成员运算符 . 。

4) 静态成员函数是类的一部分，而不是对象的一部分，在类外调用公用的静态成员函数要使用类名和域运算符“::”。

15.  友元(friend)机制允许一个类将对其非公有成员的访问权授予指定的函数或者类，友元的声明以friend开始，它只能出现在类定义的内部，友元声明可以出现在类中的任何地方：友元不是授予友元关系的那个类的成员，所以它们不受其声明出现部分的访问控制影响。通常，将友元声明成组地放在类定义的开始或结尾是个好主意。

- 友元函数：是指某些虽然不是类成员函数却能够访问类的所有成员的函数。类授予它的友元特别的访问权，这样该友元函数就能访问到类中的所有成员。

(1) 将普通的函数声明为友元函数（可以访问此类中的私有数据成员）：在类体内声明，使用关键字friend。在类体外定义不使用类作为限定符，它是非成员函数，不属于任何类。在访问类的私有数据成员，必须加上对象名。

(2) 友元成员函数：该类中的成员函数声明为另一个类的友元函数。需要对另一个类进行提前声明，只包含类名，不包含类体。在另一个类的类体中声明为友元函数的时候需要加上本类的类名与限定符“::”。

友元类：友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。当希望一个类可以存取另一个类的私有成员时，可以将该类声明为另一类的友元类。

- 关于友元类的注意事项：

(1) 友元关系不能被继承。
(2) 友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。
(3) 友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明。

优点：  可以灵活地实现需要访问若干类的私有或受保护的成员才能完成的任务；

便于与其他不支持类概念的语言(如C语言、汇编等)进行混合编程；

通过使用友元函数重载可以更自然地使用C++语言的IO流库。

缺点：一个类将对其非公有成员的访问权限授予其他函数或者类，会破坏该类的封装性和信息隐蔽，降低该类的可靠性和可维护性。

16. malloc函数

malloc函数的函数原型为：void* malloc（unsigned int size），它根据参数指定的尺寸来分配内存块，并且返回一个void型指针，指向新分配的内存块的初始位置。如果内存分配失败（内存不足），则函数返回NULL。

- 返回值

malloc的返回值为void*。我们在使用的时候，习惯对返回值进行强制类型转换：

char * p = NULL;

p = (char *)malloc(sizeof(char));

ANSI C以前的C，因为没有void*这种类型，malloc函数的返回值被简单地定义为char*，char*是不能被赋予指向其他类型变量的指针的。所以在使用malloc函数时通常需要对其返回值进行强制类型转换。

在ANSI C中，malloc函数的返回值为void*。void*类型是可以直接赋值给其他任何类型的指针。所以，上面的强制类型转换操作现在已经不需要了。

然而在c++中，任何类型的指针都可以赋给void*，而void*却不可以赋给其他类型的指针，所以在c++中使用malloc函数的时候，强制类型转换是必须的。另一方面，在c++中应该使用new来分配内存。

- malloc在堆上分配内存

malloc函数分配的内存是在堆（heap）上的。操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样代码中的delete或free语句才能正确的释放本内存空间。我们常说的内存泄露，最常见的就是堆泄露（还有资源泄露），它是指程序在运行中出现泄露，如果程序被关闭掉的话，操作系统会帮助释放泄漏的内存。

- malloc的使用

malloc函数使用起来倒是挺简单的，主要的使用范例有两种：一是动态分配结构体，通常用于被称为“链表”的数据结构中；二是分配可变长度的数组。对这两种用法就不多说了，主要是来看使用过程中的注意点：

调用malloc函数后，应该对函数返回值进行检查。前面说过，内存分配一旦失败，malloc（）会返回NULL。

char * p = NULL;

p = (char *)malloc(sizeof(char));

if(!p)

     exit(1);

！！！在程序结束时，应该调用free函数对malloc函数分配的内存进行释放。

- malloc（）与free( )

从操作系统一次性地取得比较大的内存，当程序调用malloc（）时，malloc（）便将内存给应用程序，这是malloc（）的大体实现。而当这块一次性取出来的内存不够用的时候，就请求操作系统对空间进行扩容。多次调用malloc（）（导致内存不够用了）会调用一次brk（），内存区域向地址较大的一方伸长。malloc()分配内存，会用到brk(用于小内存申请<=128kb，在堆上)或mmap2(用于大内存申请，一般是堆和栈中间)系统调用 。

K&R中记录了malloc（）最简单的一种实现方式：通过链表来实现。malloc管理的空间不一定是连续的，空闲存储空间以空闲块链表的方式组织。在这种方式下，每个块之前都加上了一个管理区域，包含一个长度、一个指向下一块的指针以及一个指向自身存储空间的指针。这些快按照储存地址的升序组织。最后一块（最高地址）指向第一块。这里使用K&R中的图加以说明：

当有申请要求时，malloc将扫描空闲块链表，直到找到一块足够大的空闲块为止，如果找不到，则向操作系统申请一个大块并加入到空闲链表中。然而在这种内存管理方式的运行环境中，一旦数组越界检查发生错误，越过了malloc()分配的内存区域写入了数据，将会破坏下一个块的管理区域，容易造成程序崩溃。

17. 运算符重载

（1）“<<”与“>>”分别是流插入运算符与流提取运算符，在使用的时候需要在本文件的模块中包含头文件stream，还用过包含“using namespace std;”。

（2）运算符重载是定义一个重载运算符的函数，使指定的运算符不仅能实现原有的功能，而且也实现在函数中指定的新的功能。在使用被重载的运算符，系统会自动调用该函数，以实现相应的功能。运算符重载是通过定义函数实现的。实质就是函数的重载。

（3）一般格式：

函数类型 operator 运算符名称 （形参表）

{对运算符的重载处理}

（4）规则：

1) 除了类属关系运算符"."、成员指针运算符"*"、作用域运算符"::"、sizeof运算符和三目运算符"?:"以外，C++中的所有运算符都可以重载。

2) 重载运算符限制在C++语言中已有的运算符范围内的允许重载的运算符之中，不能创建新的运算符。

3) 运算符重载实质上是函数重载，因此编译程序对运算符重载的选择，遵循函数重载的选择原则。

4) 重载之后的运算符不能改变运算符的优先级和结合性，也不能改变运算符操作数的个数及语法结构。

5) 运算符重载不能改变该运算符用于内部类型对象的含义。它只能和用户自定义类型的对象一起使用，或者用于用户自定义类型的对象和内部类型的对象混合使用时。其参数至少应该有一个是类对象（或者是类对象的引用）。

6) 运算符重载是针对新类型数据的实际需要对原有运算符进行的适当的改造，重载的功能应当与原有功能相类似，避免没有目的地使用重载运算符。

7) 运算符重载不能有默认的参数，否则就改变了运算符参数的个数。

8) 用于类对象的运算符一般必须重载，但是有两个例外，运算符“=”与“&”不必用户重载。赋值运算符“=”可以用于每一个类对象，利用它对同类对象间相互赋值，可以理解为系统提供默认的对象赋值运算符。地址运算符“&”可以返回类对象在内存中的起始地址。

（5）运算符重载函数的处理方式：

- 作为类的成员函数。

如果运算符重载函数为成员函数，它可以通过this指针自由的访问本来的数据成员，因此可以少写一个函数的参数。但是必须要求运算表达式的第一个参数为一个类对象，而且与运算符函数的类型相同。

- 不是类的成员函数（可以是一个普通函数），在类内把它声明为友元函数（友元运算符重载函数）。

将双目运算符重载为友元函数，由于友元函数不是该类的成员函数，因此在函数形参列表中必须有两个参数，不能省略。数学上的交换律在此不适用，所以需要运算符左侧的操作数与第一个参数对应，右侧的操作数与第二个参数对应。

- 两种重载形式的比较

在多数情况下，将运算符重载为类的成员函数和类的友元函数都是可以的。但成员函数运算符与友元函数运算符也具有各自的一些特点：

1) 一般情况下，单目运算符最好重载为类的成员函数；双目运算符则最好重载为类的友元函数。

2) 以下一些双目运算符不能重载为类的友元函数：=、()、[]、->。

3) 类型转换函数只能定义为一个类的成员函数而不能定义为类的友元函数。

4) 若一个运算符的操作需要修改对象的状态，选择重载为成员函数较好。

5) 若运算符所需的操作数（尤其是第一个操作数）希望有隐式类型转换，则只能选用友元函数。

6) 当运算符函数是一个成员函数时，最左边的操作数（或者只有最左边的操作数）必须是运算符类的一个类对象（或者是对该类对象的引用）。如果左边的操作数必须是一个不同类的对象，或者是一个内部类型的对象，该运算符函数必须作为一个友元函数来实现。

7) 当需要重载运算符具有可交换性时，选择重载为友元函数

- 重载流插入运算符“<<”与流提取运算符“>>”

C++的流插入运算符“<<”和流提取运算符“>>”是C++在类库中提供的，所有C++编译系统都在类库中提供输入流类istream和输出流类ostream。cin和cout分别是istream类和ostream类的对象。在类库提供的头文件中已经对“<<”和“>>”进行了重载，使之作为流插入运算符和流提取运算符，能用来输出和输入C++标准类型的数据。因此，凡是用“cout<<”和“cin>>”对标准类型数据进行输入输出的，都要用#include 把头文件包含到本程序文件中。

用户自己定义的类型的数据，是不能直接用“<<”和“>>”来输出和输入的。如果想用它们输出和输入自己声明的类型的数据，必须对它们重载。对“<<”和“>>”重载的函数形式如下：

istream & operator >> (istream &,自定义的类&);

ostream & operator << (ostream &,自定义的类&)；

重载运算符“>>”的函数的第一个参数和函数的类型都必须是istream&类型，第二个参数是要进行输入操作的类。重载“<<”的函数的第一个参数和函数的类型都必须是ostream&类型，第二个参数是要进行输出操作的类。因此，只能将重载“>>”和“<<”的函数作为友元函数或普通的函数，而不能将它们定义为成员函数。

return output的作用是什么？回答是能连续向输出流插入信息。output是ostream类的对象，它是实参cout的引用，也就是cout通过传送地址给output，使它们二者共享同一段存储单元，或者说output是cout的别名。因此，return output就是return cout，将输出流cout的现状返回，即保留输出流的现状。

- 优点：通过运算符的重载，扩大了C++已有的运算符的作用范围，使之能用于类对象。把运算符与类结合起来，可以在C++程序中定义出很有实用意义的而使用方便的新的数据类型，使C++具有良好的扩充性与适应性。在C++中，运算符重载是很重要的、很有实用意义的。它使类的设计更加丰富多彩，扩大了类的功能和使用范围，使程序易于理解，易于对对象进行操作，它体现了为用户着想、方便用户使用的思想。有了运算符重载，在声明了类之后，人们就可以像使用标准类型一样来使用自己声明的类。类的声明往往是一劳永逸的，有了好的类，用户在程序中就不必定义许多成员函数去完成某些运算和输入输出的功能，使主函数更加简单易读。

18. 转换构造函数：将一个其他类型的数据转换为类的对象。只有一个形参。也是一种构造函数，遵循构造函数的一般规则，通常把有一个参数的构造函数用作类型的转换，称为转换构造函数。

类型转换运算符函数（类型转换运算符重载函数）：将一个类的对象转换为另一个类型的数据。在函数名的前面不能指定函数类型，函数没有参数。其返回值的类型由函数名中指定的类型名来确定。只能成为成员函数，因为转换的主体的本类的对象，不能作为友元函数与普通函数。

Operate 类型名（）

{实现转换的语句}

如果运算符重载函数是成员函数，它的第一个参数必须是本类的对象。

一般将双目运算符函数重载为友元函数，单目运算符则对重载为成员函数。

19. 继承

(1) 类与类之间的关系

has-A，包含关系，用以描述一个类由多个“部件类”构成，实现has-A关系用类的成员属性表示，即一个类的成员属性是另一个已经定义好的类。

use-A，一个类使用另一个类，通过类之间的成员函数相互联系，定义友元或者通过传递参数的方式来实现。

is-A，即继承关系，关系具有传递性。

(2) 继承的相关概念

万事万物皆有继承这个现象，所谓的继承就是一个类继承了另一个类的属性和方法，这个新的类包含了上一个类的属性和方法，被称为子类或者派生类，被继承的类称为父类或者基类。

单继承：一个派生类只从一个基类派生。

多重继承：一个派生类有两个或者多个基类

基类与派生类的关系：基类是派生类的抽象，派生类是基类的具体化。基类综合了派生类的公共特征，派生类则在基类的基础上增加了某些特征，把抽象类变成具体的、实用的类型。

(3) 派生类的声明方式：

Class 派生类名：[继承方式] 基类名

{  派生类新增加的成员 }；

继承方式包括：公有继承，私有继承，保护继承。不写此项，则默认为私有继承。

(4) 构造一个派生类需要完成的工作：

1）从基类接受成员。（可能会造成数据的冗余）

2）调整从基类接受的成员。例如改变基类成员在派生类中的访问属性。覆盖(Override)是指派生类中存在重新定义的函数，其函数名、参数列、返回值类型必须同父类中的相对应被覆盖的函数严格一致，覆盖函数和被覆盖函数只有函数体 （花括号中的部分）不同，当派生类对象调用子类中该同名函数时会自动调用子类中的覆盖版本，而不是父类中的被覆盖函数版本，这种机制就叫做覆盖。

3）在声明派生类时增加成员。

(5) 继承方式及访问属性

1) 公用继承(public)

用公用继承方式建立的派生类称为公用派生类。其基类称为公用基类。

公有继承的特点是基类的公有成员和保护成员作为派生类的成员时，它们都保持原有的状态，而基类的私有成员仍然是私有的，不能被这个派生类的子类所访问。

2) 私有继承(private)

用私有继承方式建立的派生类称为私有派生类。其基类称为私有基类。

私有继承的特点是基类的公有成员和保护成员都作为派生类的私有成员，并且不能被这个派生类的子类所访问。私有基类的私有成员在派生类中称为不可访问的成员，只有基类的成员函数可以引用。

3) 保护继承(protected)

用保护继承方式建立的派生类称为保护派生类。其基类称为保护基类。

保护继承的特点是基类的所有公有成员和保护成员都成为派生类的保护成员，并且只能被它的派生类成员函数或友元访问，基类的私有成员仍然是私有的。

基类成员在派生类中的访问属性：

继承方式

基类的public成员

基类的protected成员

基类的private成员

public继承

仍为public成员

仍为protected成员

不可访问

Private继承

变为private成员

变为private成员

不可访问

Protected继承

变为Protected成员

变为Protected成员

不可访问

注意：父类中的private成员依然存在于子类中，但是却无法访问到。不论何种方式继承父类，子类都无法直接使用父类中的private成员。如果需要在派生类中引用基类的某些成员，则应该将基类的这些成员声明为protected。需要被外界访问的成员设置为public；只能在当前类中访问设置为private；

(6) 继承的特点

1) 子类拥有父类的所有属性和方法（除了构造函数和析构函数）。

2) 子类可以拥有父类没有的属性和方法。

3) 子类是一种特殊的父类，可以用子类来代替父类。

4) 子类对象可以当做父类对象使用。

(7) 继承中的构造和析构函数

1）父类的构造和析构

当创建一个对象和销毁一个对象时，对象的构造函数和析构函数会相应的被C++编译器调用。当在继承中，父类的构造和析构函数是如何在子类中进行调用的呢，C++规定我们在子类对象构造时，需要调用父类的构造函数完成对对继承而来的成员进行初始化，同理，在析构子类对象时，需要调用父类的析构函数对其继承而来的成员进行析构。

在派生类中定义派生类构造函数的一般形式：

派生类构造函数名(基类所需的形参，本类成员所需的形参):基类构造函数名名(基类所需参数表)

{派生类中新增成员初始化语句 }

在派生类体外定义派生类构造函数的一般形式：

派生类::派生类构造函数名(基类所需的形参，本类成员所需的形参):基类构造函数名名(基类所需参数表)

{派生类中新增成员初始化语句 }

2）父类中的构造和析构执行顺序

子类对象在创建时，会先调用父类的构造函数，如果父类还存在父类，则先调用父类的父类的构造函数，依次往上推理即可。父类构造函数执行结束后，执行子类的构造函数。当父类的构造函数不是C++默认提供的，则需要在子类的每一个构造函数上使用初始化列表的方式调用父类的构造函数。

析构函数的调用顺序和构造函数的顺序相反。

(8) 重载和覆盖的区别。

成员函数被重载的特征有：1)相同的范围（在同一个类中）；2) 函数名字相同；3) 参数不同；4) virtual关键字可有可无。
覆盖的特征有：1)不同的范围（分别位于派生类与基类）；2) 函数名字相同；3) 参数相同；4) 基类函数必须有virtual关键字。

分别位于派生类与基类的不同的成员函数，只有在函数名和参数个数相同。类型相匹配的情况下才发生同名覆盖，如果只有函数名相同，不会发生同名覆盖，而属于函数重载。
隐藏是指派生类的函数屏蔽了与其同名的基类函数，规则如下： 1)如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。2) 如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）。

(9) 含有子对象的派生类构造函数

类的数据成员中还可以包含类对象，如可以在声明一个类时包含这样的数据成员:
Student s1;// Student是已声明的类名，s1是Student类的对象
这时，s1就是类对象中的内嵌对象，称为子对象(subobject)，即对象中的对象

派生类构造函数的任务应该包括3个部分:

对基类数据成员初始化；

对子对象数据成员初始化；

对派生类数据成员初始化。

定义派生类构造函数的一般形式为：

   派生类构造函数名（总参数表列）：基类构造函数名（参数表列），子对象名(参数表列)

{派生类中新增数成员据成员初始化语句}

内置类型成员初始列表{}

执行派生类构造函数的顺序是：

调用基类构造函数，对基类数据成员初始化；

调用子对象构造函数，对子对象数据成员初始化；

再执行派生类构造函数本身，对派生类数据成员初始化。

执行派生类析构函数的顺序是：

1）执行派生类自己的析构函数。

2）对派生类新增加的成员进行清理。

3）调用子对象的析构函数，对子对象进行清理。

4）最后调用基类的析构函数，对基类进行清理。

(10) 注意：

当基类构造函数不带参数时，派生类不一定需要定义构造函数，然而当基 类的析构函数哪怕只有一个参数，也要为派生类定义构造函数，甚至所定义的派 生类析构函数的函数体可能为空，仅仅起到传递参数的作用

当基类使用缺省构造函数时或不带参数的构造函数时，则在派生类中定义构造函数时，可以省略：基类构造函数名（参数表），此时若派生类不需要构造函数，则可以不定义构造函数。

如果派生类的基类也是一个派生类，则每个派生类只需负责其直接基类的构造，依次上溯。

如果析构函数是不带参数的，在派生类中是否要定义析构函数与它所属的基类无关，故基类的析构函数不会因为派生类没有析构函数而得不到执行，他们各自是独立的

(11) 多重继承：

在多重继承中，派生类的构造函数与单继承下派生类构造函数相似，它必须负责该派生类所有基类构造函数以及对象成员（如果有的话）构造函数的调用。同时，派生类的参数必须包含完成所有基类、对象成员以及派生类中新增数据成员初始化所需的参数。

派生类构造函数执行顺序如下：

（1）所有基类的构造函数，多个基类构造函数的执行顺序取决于定义派生类时所指定的顺序，与派生类构造函数中所定义的成员初始化列表的参数顺序无关；

（2）对象成员的构造函数；

（3）派生类本省的构造函数。

加上虚基类后，它的初始化在语法上与一般多继承的初始化是相同的，但在调用构造函数的顺序上有点差别。

（1）先调用虚基类构造函数，然后调用非虚基类的构造函数。

（2）当同一层有多个虚基类，按照他们的声明顺序调用它们的构造函数；

（3）当虚基类是由非虚基类派生时，则先调用基类构造函数，再调用派生类构造函数。

(12) 虚基类：

如果一个派生类有多个直接基类，而这些直接基类又有一个共同的基类，则在最终的派生类中会保留该间接共同基类数据成员的多份同名成员。引入虚基类，使得在继承间接共同基类的时候只保留一份成员。

现在，将类A声明为虚基类，方法如下:

class A//声明基类A

{…};

class B :virtual public A//声明类B是类A的公用派生类，A是B的虚基类

{…};

class C :virtual public A//声明类C是类A的公用派生类，A是C的虚基类

{…};

注意: 虚基类并不是在声明基类时声明的，而是在声明派生类时，指定继承方式时声明的。因为一个基类可以在生成一个派生类时作为虚基类，而在生成另一个派生类时不作为虚基类。

声明虚基类的一般形式为：

class 派生类名: virtual 继承方式 基类名

经过这样的声明后，当基类通过多条派生路径被一个派生类继承时，该派生类只继承该基类一次。

需要注意: 为了保证虚基类在派生类中只继承一次，应当在该基类的所有直接派生类中声明为虚基类。否则仍然会出现对基类的多次继承。

虚基类的初始化如果在虚基类中定义了带参数的构造函数，而且没有定义默认构造函数，则在其所有派生类(包括直接派生或间接派生的派生类)中，通过构造函数的初始化表对虚基类进行初始化。规定:在最后的派生类中不仅要负责对其直接基类进行初始化，还要负责对虚基类初始化。C++编译系统只执行最后的派生类对虚基类的构造函数的调用，而忽略虚基类的其他派生类(如类B和类C)对虚基类的构造函数的调用，这就保证了虚基类的数据成员不会被多次初始化。

(13) 基类与派生类的转换：

基类与派生类对象之间有赋值兼容关系，由于派生类中包含从基类继承的成员，因此可以将派生类的值赋给基类对象，在用到基类对象的时候可以用其子类对象代替。

（1）派生类对象可以向基类对象赋值。

可以用子类(即公用派生类)对象对其基类对象赋值。只能用子类对象对其基类对象赋值，而不能用基类对象对其子类对象赋值，因为基类对象不包含派生类的成员，无法对派生类的成员赋值。同理，同一基类的不同派生类对象之间也不能赋值。

（2）派生类对象可以替代基类对象向基类对象的引用进行赋值或初始化。

（3）如果函数的参数是基类对象或基类对象的引用，相应的实参可以用子类对象。

（4）派生类对象的地址可以赋给指向基类对象的指针变量，也就是说，指向基类对象的指针变量也可以指向派生类对象。

(14) 类的组合：在一个类中以另一个类的对象作为数据成员。

20. 多态性

概念：指相同的对象收到不同的消息或者不同的对象收到相同的消息时产生的不同的实现动作。

C++支持两种多态：编译时多态（静态）、运行时多态（动态）。

- 静态多态是通过函数的重载来实现的（运算符重载实际上也属于函数的重载）。要求在程序编译的时候就知道调用函数的全部信息。静态多态性的函数调用速度快、效率高、但是缺乏灵活性，在程序运行前就决定了执行的函数与方法。

- 动态多态性是程序运行过程中才动态地确定操作所针对的对象，运行时多态性是通过虚函数来实现的。由虚函数实现的动态多态性就是：同一类族中不同类的对象，对同一函数调用作出不同的响应。

虚函数的作用是允许在派生类中重新定义与基类同名的函数，并且可以通过基类指针或引用来访问基类和派生类中的同名函数。

虚函数的使用方法是：

1) 在基类用virtual声明成员函数为虚函数。

2) 这样就可以在派生类中重新定义此函数，为它赋予新的功能，并能方便地被调用。在类外定义虚函数时，不必再加virtual。

3) 在派生类中重新定义此函数，要求函数名、函数类型、函数参数个数和类型全部与基类的虚函数相同，并根据派生类的需要重新定义函数体。

4) C++规定，当一个成员函数被声明为虚函数后，其派生类中的同名函数都自动成为虚函数。因此在派生类重新声明该虚函数时，可以加virtual，也可以不加，但习惯上一般在每一层声明该函数时都加virtual，使程序更加清晰。如果在派生类中没有对基类的虚函数重新定义，则派生类简单地继承其直接基类的虚函数。

5) 定义一个指向基类对象的指针变量，并使它指向同一类族中需要调用该函数的对象。

6) 通过该指针变量调用此虚函数，此时调用的就是指针变量指向的对象的同名函数。

通过虚函数与指向基类对象的指针变量的配合使用，就能方便地调用同一类族中不同类的同名函数，只要先用基类指针指向即可。如果指针不断地指向同一类族中不同类的对象，就能不断地调用这些对象中的同名函数。这就如同前面说的，不断地告诉出租车司机要去的目的地，然后司机把你送到你要去的地方。

确认具体对象的过程叫关联(binding)，在这里指把一个函数与类对象捆绑在一起，建立关联。

静态关联：函数重载和通过对象名调用的虚函数，在编译时即可确定其调用的虚函数属于哪一个类，其过程称为静态关联，由于是在运行前关联的，所以又叫早期关联。

动态关联：在运行时，基类指针变量指向了某个类对象，然后通过这个基类指针去调用虚函数。由于是在运行时把虚函数与对象“绑定”在一起， 因此，此过程称为动态关联。由于动态关联是在编译后运行阶段进行的，所以又称为滞后关联。

使用虚函数时的注意点：

- 只能用virtual声明类的成员函数，使他成为虚函数，而不能将类外的普通函数声明为虚函数。

- 一个成员函数在被声明为虚函数后，在同一类族中的类就不能定义一个非virtual的但是与该虚函数具有相同参数和返回值类型的函数。

怎么判断是否把一个成员函数声明为虚函数？

- 首先看成员函数所在的类是否会成为基类。然后看成员函数在类的继承后有无可能被改进功能，如果希望改变其功能的，一般把它声明为虚函数。

- 如果成员函数在类被继承后不被修改，或派生类用不到该函数，则不要把它声明为虚函数。

- 应该考虑对成员函数的调用是通过对象名还是通过基类指针或引用来访问，如果通过基类指针或引用来访问的，应该考虑用虚函数。

- 有时，在定义虚函数时，不定义其函数体，即函数体是空的。

使用虚函数，系统有一定的开销，但一个类有虚函数时，编译系统会为该类创建一个虚函数表，它是一个指针数组，存放每个虚函数的入口地址。

 

21. 当派生类的对象从内存中撤销时一般先调用派生类的析构函数，然后再调用基类的析构函数。但是，如果用new运算符建立了临时对象，若基类中有析构函数，并且定义了一个指向该基类的指针变量。在程序用带指针参数的delete运算符撤销对象时，会发生一个情况:系统会只执行基类的析构函数，而不执行派生类的析构函数。

当基类的析构函数为虚函数时，无论指针指的是同一类族中的哪一个类对象，系统会采用动态关联，调用相应的析构函数，对该对象进行清理工作。
如果将基类的析构函数声明为虚函数时，由该基类所派生的所有派生类的析构函数也都自动成为虚函数，即使派生类的析构函数与基类的析构函数名字不相同。
最好把基类的析构函数声明为虚函数。这将使所有派生类的析构函数自动成为虚函数。这样，如果程序中显式地用了delete运算符准备删除一个对象，而delete运算符的操作对象用了指向派生类对象的基类指针，则系统会调用相应类的析构函数。
虚析构函数的概念和用法很简单，但它在面向对象程序设计中却是很重要的技巧。

 

22. 纯虚函数声明： virtual 函数类型 函数名 （参数表列） = 0；
    （1）纯虚函数没有函数体；
    （2）最后面的“=0”并不表示函数返回值为0，它只起形式上的作用，告诉编译系统“这是虚函数”；
    （3）这是一个声明语句，最后有分号。
    纯虚函数只有函数的名字而不具备函数的功能，不能被调用。
    纯虚函数的作用是在基类中为其派生类保留一个函数的名字，以便派生类根据需要对他进行定义。如果在基类中没有保留函数名字，则无法实现多态性。
    如果在一个类中声明了纯虚函数，在其派生类中没有对其函数进行定义，则该虚函数在派生类中仍然为纯虚函数。

23. 抽象类：不用定义对象而只作为一种基本类型用作继承的类叫做抽象类（也叫接口类），凡是包含纯虚函数的类都是抽象类，抽象类的作用是作为一个类族的共同基类，为一个类族提供公共接口，抽象类不能实例化出对象。
纯虚函数在派生类中重新定义以后，派生类才能实例化出对象。

（1）一个基类如果包含一个或一个以上纯虚函数，就是抽象基类。抽象基类不能也没必要定义对象。

（2）在类的层次结构中，顶层或最上面几层可以是抽象基类。抽象基类体现了本类族中各类的共性，把各类中共有的成员函数集中在抽象基类中声明。

（3）抽象基类是本类族的共公共接口，即就是从同一基类中派生出的多个类有同一接口。
总结：

1、派生类重写基类的虚函数实现多态，要求函数名、参数列表、返回值完全相同。(协变除外)
2、基类中定义了虚函数，在派生类中该函数始终保持虚函数的特性。
3、只有类的非静态成员函数才能定义为虚函数，静态成员函数不能定义为虚函数。
4、如果在类外定义虚函数，只能在声明函数时加virtual关键字，定义时不用加。
5、构造函数不能定义为虚函数，虽然可以将operator=定义为虚函数，但最好不要这么做，使用时容易混淆。
6、不要在构造函数和析构函数中调用虚函数，在构造函数和析构函数中，对象是不完整的，可能会出现未定义的行为。
7、虚表是所有类对象实例共用的虚表剖析。